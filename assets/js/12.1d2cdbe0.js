(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{568:function(t,_,v){"use strict";v.r(_);var n=v(9),a=Object(n.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h4",{attrs:{id:"_1-认知"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-认知"}},[t._v("#")]),t._v(" 1.认知：")]),t._v(" "),v("p",{staticStyle:{"text-indexnt":"2em"}},[t._v("\n  网页生成的时候，至少会进行一次渲染，并且在用户访问和交互中，还会不断的触发"),v("span",{staticStyle:{color:"#32acdf"}},[t._v("重排(reflow)")]),t._v("和"),v("span",{staticStyle:{color:"#32acdf"}},[t._v("重绘(repaint)")]),t._v("。\n")]),t._v(" "),v("ul",[v("li",{staticStyle:{"font-weight":"bold"}},[t._v("重绘：某些元素的外观被改变，例如：元素的填充颜色。")]),t._v(" "),v("li",{staticStyle:{"font-weight":"bold"}},[t._v("重排：重新生成布局，重新排列元素。")])]),t._v(" "),v("em",[t._v("总结：重绘不一定导致重排，但重排一定会导致重绘")]),t._v(" "),v("h4",{attrs:{id:"_2-概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-概念"}},[t._v("#")]),t._v(" 2.概念：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th"),t._v(" "),v("th",[t._v("重排")]),t._v(" "),v("th",[t._v("重绘")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("概念")]),t._v(" "),v("td",[t._v("dom的变化影响了元素的"),v("span",{staticStyle:{color:"#71C671","font-weight":"bold","font-size":"16px"}},[t._v("几何信息(元素的位置和尺寸大小)")]),t._v("，简单来说就是重新生成布局，重新排列元素")]),t._v(" "),v("td",[t._v("当一个元素的外观发生改变，但"),v("span",{staticStyle:{color:"#71C671","font-weight":"bold","font-size":"16px"}},[t._v("没有改变布局")]),t._v(",重新把元素外观绘制出来的过程")])]),t._v(" "),v("tr",[v("td",[t._v("发生情况")]),t._v(" "),v("td",[t._v("1. 初始渲染"),v("br"),t._v(" 2. add/remove可见的dom元素"),v("br"),t._v(" 3. 改变元素位置"),v("br"),t._v(" 4. 改变元素尺寸(边距，边框，宽高，填充)"),v("br"),t._v(" 5. 改变元素字体大小"),v("br"),t._v(" 6. 改变浏览器窗口大小"),v("br"),t._v(" ...")]),t._v(" "),v("td",[t._v("1. 改变颜色"),v("br"),t._v(" 2. background-*"),v("br"),t._v(" 3.box-shadow"),v("br"),t._v(" 4. border-style / border-radius")])])])]),t._v(" "),v("h4",{attrs:{id:"_3-重排优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-重排优化"}},[t._v("#")]),t._v(" 3.重排优化：")]),t._v(" "),v("p",[t._v("\n  1.减少重排范围:\n    尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。\n")]),t._v(" "),v("ul",[v("li",[t._v("\n    尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。\n  ")]),t._v(" "),v("li",[t._v("\n    不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。\n  ")])]),t._v(" "),v("p",[t._v("\n  2.减少重排次数:\n")]),t._v(" "),v("ul",[v("li",[t._v("\n    样式集中改变:\n      改变类名而不是修改样式。\n      "),v("b",[t._v('el.className += " className";')])]),t._v(" "),v("li",[t._v("\n    将dom离线：不在当前dom树中修改:\n      使用display: none(只有一次重排重绘);\n      visibility : hidden(只对重绘有影响，不影响重排);\n      通过 documentFragment 创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排;\n      复制节点，在副本上工作，然后替换它;\n  ")]),t._v(" "),v("li",[t._v("\n    使用 absolute 或 fixed 脱离文档流:\n      使用绝对定位会使的该元素单独成为渲染树中 body 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。\n  ")]),t._v(" "),v("li",[t._v("\n    优化动画:\n      启动GPU加速：\n        Canvas2D\n        布局合成\n        CSS3转换（transitions）\n        CSS3 3D变换（transforms）\n        WebGL和视频(video)\n  ")])])])}),[],!1,null,null,null);_.default=a.exports}}]);